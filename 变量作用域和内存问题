1，在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者说是arguments对象中的一个元素），在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反应到函数外部

在局部作用域中修改的对象会在全局作用域反应出来，就说明参数是按引用传递的，这是一个错误的想法

在使用var关键字声明变量时，这个变量会被自动添加到距离最近的可以环境中

function setName(obj) {
	obj.name='tony';
	obj = new Object();
	obj.name='mary';
	obj.age=12;
}

var person = new Object();
setName(person);
alert(person.name);



这个例子与前一个例子的唯一区别，就是在setName(）函数中添加了两行代码：一行代码为obj
重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递
给setName(）后，其narne属性被设置为"Nicholas”。然后，又将一个新对象献给变量obj，同时将
其name属性设置为"Greg"。如果person是按引用传递的，那么person就会自动被修改为指向其
name属性值为·Greg·的新对象。但是，当接下再访问person.name时，显示的值仍然是Nicholas。
这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj
时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。
可以把ECMAscriPt函数的参数想象成局部变量．




2，typeof 用来检测基本类型可以，但是对于引用类型就有些力不从心了，instanceof可以用来检测引用类型
{} instanceof Object --》true


3，每一个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中，我们编写代码无法访问到这个对象，但是解析器在处理数据时会在后台使用它


每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行完成后，栈将其环境弹出，把控制器返回给之前的执行环境。ECMAScript程序中执行流正式由这个方便的机制控制着


当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，
是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代
码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。
活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作
用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这
样，一直延续到全局执行环境．全局执行环境的变量对象始终都是作用城链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用城链的前端开
始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
